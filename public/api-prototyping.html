<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-03-27 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>rest api prototyping</title>
<meta name="generator" content="Org mode">
<meta name="author" content="[[https://me.jowj.net][josiah]]josiah">
<link rel="stylesheet" type="text/css" href="css/my-dark.css" />---
</head>
<body>
<div id="preamble" class="status">
<a href="./index.html">About</a>
<a href="./articles.html">Articles</a>
<a href="./projects/index.html">Projects</a>
<a href="./atom.xml">Feed</a>
</div>
<div id="content">
<header>
<h1 class="title">rest api prototyping</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga8e6e1d">the problem</a></li>
<li><a href="#orga47ecb9">Authentication and Authorization in Cylance</a>
<ul>
<li><a href="#orgd5856a4">python code</a></li>
<li><a href="#orgdf0f554">restclient example</a></li>
</ul>
</li>
<li><a href="#org6ab54f7">Troubleshooting python and org-babel</a></li>
</ul>
</div>
</nav>

<div id="outline-container-orga8e6e1d" class="outline-2">
<h2 id="orga8e6e1d">the problem</h2>
<div class="outline-text-2" id="text-orga8e6e1d">
<p>
lately i've been working on a lot of web API glue projects. these are usually simple things like "service1 needs to send messages to service2 in a particular format, with a particular set of priviledges." Sometimes its more complicated, but that's usually what it breaks down to.
</p>


<p>
at first I was writing python code the whole time, exploring the API through python (ugh) and kept getting frustrated; it felt like I wasn't able to go as fast as I would like, I kept making silly mistakes that I wouldn't catch until much later, etc. To fix this, i've moved to prototyping in <a href="https://github.com/pashky/restclient.el">restclient.el</a> - this is a featureful rest client that you interact with through plain text (i.e., you can version control it!) within emacs. 
</p>

<p>
this has worked great for a lot of things, but falls short when you have to generate an auth token programmatically (instead of using a static key) for each request. this problem is solvable using: a different kind of glue lol. i use python to create the auth token, org-babel to register the result and then pass it to `restclient` which will continue to be my prototyping tool of choice. this write up will go over how i stitch each part together; i'll use Cylance as an example service for api requests.
</p>
</div>
</div>

<div id="outline-container-orga47ecb9" class="outline-2">
<h2 id="orga47ecb9">Authentication and Authorization in Cylance</h2>
<div class="outline-text-2" id="text-orga47ecb9">
<p>
Cylance relies on something called JWT (JSON Web Token). There's an RFC for this here: <a href="https://tools.ietf.org/html/rfc7519">https://tools.ietf.org/html/rfc7519</a>. This is not possible to generate within `restclient`, so we do it in python.
</p>

<p>
To generate the JWT, in Cylance's case, we care about:
</p>

<p>
<code>TID_VAL</code>, which is the tenant ID. You can find this by logging into the console &gt; settings &gt; integrations.
<code>APP_ID</code> and <code>APP_SECRET</code>, which is under the same place, but you'll have to expand the custom application.
</p>

<p>
We'll add a <code>#+name:</code> argument to the top of the <code>org-mode</code> src block so that the output from the block can be registered for later use.
</p>
</div>

<div id="outline-container-orgd5856a4" class="outline-3">
<h3 id="orgd5856a4">python code</h3>
<div class="outline-text-3" id="text-orgd5856a4">
<div class="org-src-container">
<pre class="src src-python">import uuid
import json
import requests
import jwt
import pdb
from datetime import datetime, timedelta

# initial auth test setup
JTI_VAL = str(uuid.uuid4())
TID_VAL = ""     # The tenant's unique identifier.
APP_ID = ""      # The application's unique identifier.
APP_SECRET = ""  # application's secret to sign the auth token with.

# 30 minutes from now
TIMEOUT = 1800
NOW = datetime.utcnow()
TIMEOUT_DATETIME = NOW + timedelta(seconds=TIMEOUT)
EPOCH_TIME = int((NOW - datetime(1970, 1, 1)).total_seconds())
EPOCH_TIMEOUT = int((TIMEOUT_DATETIME - datetime(1970, 1, 1)).total_seconds())

AUTH_URL = "https://protectapi.cylance.com/auth/v2/token"

CLAIMS = {
    "exp": EPOCH_TIMEOUT,
    "iat": EPOCH_TIME,
    "iss": "http://cylance.com",
    "sub": APP_ID,
    "tid": TID_VAL,
    "jti": JTI_VAL
}

ENCODED = jwt.encode(CLAIMS, APP_SECRET, algorithm='HS256')
# lol you have to decode from a bytes object to a string because
# bytes aren't fucking json serializable
# you never seem to need to re-encode them? python is so fucking weird.
ENCODED = ENCODED.decode()

PAYLOAD = {"auth_token": ENCODED}
HEADERS = {"Content-Type": "application/json; charset=utf-8"}
RESP = requests.post(AUTH_URL, headers=HEADERS, data=json.dumps(PAYLOAD))
print(json.loads(RESP.text)['access_token'])
</pre>
</div>

<p>
this will generate a token and attach it to the name space <code>jwt_token</code> as defined previously.
</p>
</div>
</div>


<div id="outline-container-orgdf0f554" class="outline-3">
<h3 id="orgdf0f554">restclient example</h3>
<div class="outline-text-3" id="text-orgdf0f554">
<p>
once the previous block has run to generate the json web token  we can pass it on to this restclient block and use it to query Cylance's API through <code>restclient.el</code> going forward! in order to pass the output from the registered name we used before, <code>jwt_token</code>, we add an argument to the <code>BEGIN_SRC</code> header, like <code>:var x=jwt_token</code>. Then, we can set a <code>restclient</code> local variable equal to the <code>org-babel</code> super-variable and use it within the rest of the src block, as seen below:
</p>

<div class="org-src-container">
<pre class="src src-restclient"># auth.test
:cylance_jwt_token = :x
GET https://protectapi.cylance.com/users/v2?page=1&amp;page_size=1
Authorization: Bearer :cylance_jwt_token
Content-Type: application/json
User-Agent: Emacs Restclient

</pre>
</div>

<p>
this will return my user (again, i've disturbed the output but it is roughly what's returned):
</p>

<div class="org-src-container">
<pre class="src src-js">{
  "page_number": 1,
  "page_size": 1,
  "total_pages": 6,
  "total_number_of_items": 6,
  "page_items": [
    {
      "id": "",
      "tenant_id": "",
      "first_name": "",
      "last_name": "",
      "email": "me@thiscompanyyo.isit",
      "has_logged_in": true,
      "role_type": "",
      "role_name": "i am the boss",
      "default_zone_role_type": "",
      "default_zone_role_name": "",
      "zones": [],
      "date_last_login": "2019-11-22T14:52:13",
      "date_email_confirmed": null,
      "date_created": "2019-05-17T17:16:52",
      "date_modified": "2019-05-17T17:16:52"
    }
  ]
}
// GET https://protectapi.cylance.com/users/v2?page=1&amp;page_size=1
// HTTP/1.1 200 OK
// Content-Encoding: gzip
// Content-Type: application/json; charset=utf-8
// Date: Fri, 22 Nov 2019 16:24:13 GMT
// Server: openresty
// Content-Length: 339
// Connection: keep-alive
// Request duration: 0.305690s
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org6ab54f7" class="outline-2">
<h2 id="org6ab54f7">Troubleshooting python and org-babel</h2>
<div class="outline-text-2" id="text-org6ab54f7">
<p>
I had huge issues with python virtual environemtns and org-babel while initially setting up this environment. i once had an issue with emacs, I belive in an older version (25 or below i think) where it couldn't find my python binary on macOS. to fix this i manually set it in my <code>init.el</code> file, which worked for a long time.
</p>

<p>
however, if you start using venvs <b>within emacs</b>, tools like <code>pvenv</code> and <code>venv</code> <b>will not overwrite the global variable set with the new venv specific python binaries</b> if you've globally set the py binary location. This killed me. below are some blocks i used to troubleshoot what was going on.
</p>

<p>
This one is pretty straight forward: do i have a virtual env active, and where is the python binary as seen by the shell:
</p>

<div class="org-src-container">
<pre class="src src-shell">echo $VIRTUAL_ENV
which python
</pre>
</div>

<p>
Same deal, only "where is the python binary as seen in the python session". in my case, this was showing me the system python binary even when the <b>shell</b> was showing me the venv binary.
</p>
<div class="org-src-container">
<pre class="src src-python">import sys
print('\n'.join(sys.path))
</pre>
</div>

<p>
this block just proved that i could in fact import the right modules that were only in the venv.
</p>
<div class="org-src-container">
<pre class="src src-python">import jwt
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: </p>
<p class="creator">Made with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.3 (<a href="https://orgmode.org">Org</a> mode 9.1.9)</p>
</div>
</body>
</html>
